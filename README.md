# FATEC-bertoti

Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.


We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.


So, what is software engineering?

Based on these distinctions, we can define software engineering as:

A broader discipline than programming, encompassing the entire lifecycle of software, from initial development to long-term maintenance.
An application of engineering principles to software creation, considering factors like efficiency, scalability, maintainability, and adaptability over time.
A practice involving complex decision-making with significant trade-offs and long-term consequences.
In essence, software engineering goes beyond writing code to encompass the entire process of building and sustaining high-quality, efficient, and evolving software systems that meet stakeholder needs over time.

Every software undergoes deprecations over time, and engineering serves to reduce the friction of time in the usefulness of the software. Scale is extremely important in software engineering, as a product can become entirely unviable if it grows under limiting pillars. Tradeoffs will always exist, and it is in software engineering that the analysis is made of which ones are bearable for the product that the software intends to deliver and the problems they aim to solve
